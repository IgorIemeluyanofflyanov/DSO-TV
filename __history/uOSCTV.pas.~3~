unit uOSCTV;

interface

uses Windows, Classes, SysUtils, Forms, MMSystem, uOSCReader, Math, Dialogs, vdsolib;


type
  TRowEvent = procedure(var RowDataToFill: Pointer; RowNumber: Integer;
    var MaxX: DWORD; var RowVolts: PDoubleArray) of object;

type
  TSynhroPulse = (spNone, spHSYN, spVSYN);

type
  TOSCTVstatus = (osSetup, osProcessData, osWaitFirstFrame, osWaitNewFrame,
    osWaitEndRow, osWaitStartRowOrFrame);

type
  TOnDebug = procedure(NewOSCTVstatus: TOSCTVstatus; DebugStr: String)
    of object;


var


    fStatus: TOSCTVstatus;
    fBytesPerMicroSec: Integer;
    fCurrentPosInBytes: Int64;
    fBytesInColor: Integer;
    lastPossynhroNewFrameVoltage: Int64;
    lastTimeSynhroPulse: Int64;
    timeTolastTimeSynhroPulse: Int64;
    synhroTimes: Integer;
    VSYNcount: Integer;
    xPos: Integer;
    RowNum: Integer;
    FOnDebug: TOnDebug;
    synhroVoltageLevel: Double;
    lastPulseData: Double;
    aRowData: PByteArray;
    MaxX: DWORD;
    lastRowsValues: PDoubleArray;
    BuffProcess: Integer;

    function CurrentPosInMicroSec: Int64;

    function IsSynhroPulse(PulseData: Double): TSynhroPulse;

    procedure ChangeStat(aNewStat: TOSCTVstatus);

procedure  TOSCTV_Create;


var
    IsEvenFrame: Boolean;
    DebugVoltage: Double;
    MinVoltageLevel: Double;
    MaxVoltageLevel: Double;
    ColorVoltageGain: Double;
    ColorVoltageDelta: Double;
    DebugStr: string;
    function VoltToColor(Volt: Double): Byte;
    function StatusAsString(OSCTVstatus: TOSCTVstatus): String;
    procedure OnReadDataTV(aData: PDoubleArray; aSize: DWORD);

    procedure OnNewFrame;

implementation
uses uOSCmain;

{ uOSCTV }


procedure OnNewFrame;
begin
  Inc(FormuOSCR.cnt);
  FormuOSCR.img1.Repaint;
  // Memo1.Lines.Add(Format('NewFrame %d; %d',[cnt,OSCTV.PositionInMicroSec]));
end;

procedure OnNewRow(var RowDataToFill: Pointer; RowNumber: Integer;
  var MaxX: DWORD; var RowVolts: PDoubleArray);
begin
  if RowNumber < FormuOSCR.img1.Picture.Bitmap.Height then
    RowDataToFill := FormuOSCR.img1.Picture.Bitmap.ScanLine[RowNumber];
  MaxX := 1500;
  RowVolts := nil;
  {
    if FrameDoubleArray[RowNumber] = nil then
    GetMem(FrameDoubleArray[RowNumber],SizeOf(Double)*MaxX);

    RowVolts := FrameDoubleArray[RowNumber];
  }




  // Memo1.Lines.Add(Format('%.8dR %.7f %d ',[OSCTV.PositionInMicroSec, OSCTV.DebugVoltage, MaxX]));
  // img1.Picture.Bitmap.Width div 2;

  // lbl1.Caption:=format('Min: %.3f; Max: %.3f',[OSCTV.MinVoltageLevel, OSCTV.MaxVoltageLevel]);

  // img1.Repaint;
  Application.ProcessMessages;
  {
    if MaxRow <  RowNumber then
    begin
    Memo1.Lines.Add(Format('New max row in %d usec; %d',[OSCTV.PositionInMicroSec, RowNumber]));
    MaxRow:=RowNumber;
    end;
  }
end;


procedure ChangeStat(aNewStat: TOSCTVstatus);
begin
  // if Assigned(OnDebug) then
  // OnDebug(aNewStat);
  fStatus := aNewStat;
end;

procedure  TOSCTV_Create;
begin
  fStatus := osSetup;
  fBytesPerMicroSec := fSampleRate div 1000000;
  fCurrentPosInBytes := 0;
  fBytesInColor := 3;
  MinVoltageLevel := 0;
  MaxVoltageLevel := 0;
  lastTimeSynhroPulse := $FFFFFFFF;
  timeTolastTimeSynhroPulse := 0;
  synhroVoltageLevel := -30;
  aRowData := 0;
  ColorVoltageGain := 3;
  ColorVoltageDelta := 3;
  lastRowsValues := nil;
end;

function CurrentPosInMicroSec: Int64;
begin
  result := fCurrentPosInBytes div fBytesPerMicroSec;
end;

function IsSynhroPulse(PulseData: Double): TSynhroPulse;
begin
  result := spNone;
  if DWORD(fStatus) <= 0 then
    Exit;

  if (lastPulseData <= synhroVoltageLevel) then
    Inc(synhroTimes);

  if (synhroTimes div fBytesPerMicroSec > 15) and
    (lastPulseData > synhroVoltageLevel + 0.1) then // Pulse > 3us
  begin
    Inc(VSYNcount);
    if (VSYNcount > 18) then
    begin
      result := spVSYN;
      synhroTimes := 0;
      VSYNcount := 0;
    end;
  end;

  if (synhroTimes div fBytesPerMicroSec > 3) and
    (synhroTimes div fBytesPerMicroSec < 15) and
    (lastPulseData > synhroVoltageLevel + 0.1) then // Pulse > 3us
  begin
    result := spHSYN;
    synhroTimes := 0;
  end;

  lastPulseData := PulseData;
end;

procedure OnReadDataTV(aData: PDoubleArray; aSize: DWORD);
var
  i: Integer;
  aIsSynhroPulse: TSynhroPulse;
begin

  DataIsReady:= false;

  Inc(BuffProcess);
  DebugStr := IntToStr(BuffProcess);
  // inherited;//(OnReadData) then  OnReadData (aData; aSize);

  i := 0;
  aRowData := nil;
  while (i < aSize) do
  begin

    DebugVoltage := aData[i];
    if (MinVoltageLevel > aData[i]) then
      MinVoltageLevel := aData[i];
    if (MaxVoltageLevel < aData[i]) then
      MaxVoltageLevel := aData[i];

    aIsSynhroPulse := IsSynhroPulse(aData[i]);

    if (DWORD(aIsSynhroPulse) > 0) then
      lastTimeSynhroPulse := CurrentPosInMicroSec;

    timeTolastTimeSynhroPulse := CurrentPosInMicroSec - lastTimeSynhroPulse;

    case fStatus of
      osSetup:
        begin
          if CurrentPosInMicroSec > 500 then // wait 500us
          begin
            synhroVoltageLevel := MinVoltageLevel + 0.15;
            ChangeStat(osProcessData);
          end;

        end;
      osProcessData:
        case aIsSynhroPulse of
          spNone:
            begin
              if (Assigned(aRowData)) and (xPos < MaxX) then
              begin
                aRowData[xPos] := VoltToColor(aData[i]);
                if lastRowsValues <> nil then
                  lastRowsValues[xPos] := aData[i];
                Inc(xPos);
              end;

            end;
          spVSYN:
            begin

            OnNewFrame;

              IsEvenFrame := not IsEvenFrame;

              if IsEvenFrame then
                RowNum := 0
              else
                RowNum := 1;
              MaxX := xPos;


              begin
                OnNewRow(Pointer(aRowData), RowNum, MaxX, lastRowsValues);
              end;
              xPos := 0;
            end;
          spHSYN:
            begin
              RowNum := RowNum + 2;

              MaxX := xPos;

                OnNewRow(Pointer(aRowData), RowNum, MaxX, lastRowsValues);


              xPos := 0;
            end;
        end;

    end;
    Inc(fCurrentPosInBytes);
    Inc(i);
  end;

end;


function StatusAsString(OSCTVstatus: TOSCTVstatus): String;
begin
  case OSCTVstatus of
    osWaitFirstFrame:
      result := 'osWaitFirstFrame';
    osWaitNewFrame:
      result := 'osWaitNewFrame';
    osWaitEndRow:
      result := 'osWaitEndRow';
    osWaitStartRowOrFrame:
      result := 'osWaitStartRowOrFrame';
  end;
end;

function VoltToColor(Volt: Double): Byte;
var
  delta, rs: Double;
begin // MinVoltageLevel

  delta := (MaxVoltageLevel + Abs(MinVoltageLevel)) / ColorVoltageDelta;
  Volt := Abs(MinVoltageLevel - Volt) - delta;
  if Volt < 0 then
    Volt := 0;
  Volt := Volt * ColorVoltageGain;
  {
    DebugStr:=Format('Range: %.3f;',[MaxVoltageLevel + Abs(MinVoltageLevel)]);
    DebugStr:=Format('%sDelta: %.3f;',[DebugStr,delta]);
    DebugStr:=Format('%sVolt: %.3f',[DebugStr,Volt]);

  }
  rs := 255 * Volt / (MaxVoltageLevel + Abs(MinVoltageLevel));
  if rs > 255 then
    rs := 255;
  if rs < 0 then
    rs := 0;
  result := Ceil(rs)

end;

end.
