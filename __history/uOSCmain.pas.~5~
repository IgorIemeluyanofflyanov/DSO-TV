// https://github.com/vvkuzmin1973

unit uOSCmain;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, MMSystem,
  Forms,
  Dialogs, StdCtrls, uOSCReader, uOSCTV, ExtCtrls, ComCtrls, vdsolib;

type
  TFormuOSCR = class(TForm)
    img1: TImage;
    pnl1: TPanel;
    lst1: TListBox;
    btn2: TButton;
    btn3: TButton;
    btn4: TButton;
    btn6: TButton;
    odmain: TOpenDialog;
    lbl1: TLabel;
    tbGain: TTrackBar;
    tbDelta: TTrackBar;
    lbl2: TLabel;
    PaintBox1: TPaintBox;
    Memo1: TMemo;
    Label1: TLabel;
    TrackBar1: TTrackBar;
    TrackBar2: TTrackBar;
    Splitter1: TSplitter;
    procedure FormCreate(Sender: TObject);
    procedure btn2Click(Sender: TObject);
    procedure btn4Click(Sender: TObject);
    procedure tbDeltaChange(Sender: TObject);

    procedure lst1Click(Sender: TObject);

  private
    { Private declarations }

  public
    { Public declarations }

    cnt: Integer;

    FrameDoubleArray: array of PDoubleArray;
    MaxRow: Integer;

    procedure OnDeviceReadData(aData: PDoubleArray; aDataSize: DWORD);

  end;

var
  FormuOSCR: TFormuOSCR;
  HPal: HPALETTE = 0;

implementation

{$R *.dfm}

uses Math;

function BW: HPALETTE;
var
  DC: HDC;
  BI: PBitMapInfo;
  Pal: PLogPalette;
  i: Integer;
  ResIdHandle: THandle;
  ResDataHandle: THandle;
  Bitmap: HBitmap;
  C: HWnd;
  OldPalette, Palette: HPALETTE;

begin
  Bitmap := 0;
  Palette := 0;

  GetMem(Pal, SizeOf(TLogPalette) + 256 * SizeOf(TPaletteEntry));
  for i := 0 to 255 do
    with Pal^.palPalEntry[i] do
    begin

      // case i of
      // 0..32    : begin peRed  := 0;  peGreen:= 0; peBlue := 0; end;
      // 33..64   : begin peRed  := 0;  peGreen:= 0; peBlue := 255; end;
      // 65..96   : begin peRed  := 255;  peGreen:= 0; peBlue := 0; end;
      // 97..128  : begin peRed  := 255;  peGreen:= 0; peBlue := 255; end;
      // 129..160 : begin peRed  := 0;  peGreen:= 255; peBlue := 0; end;
      // 161..192 : begin peRed  := 0;  peGreen:= 255; peBlue := 255; end;
      // 193..224 : begin peRed  := 255;  peGreen:= 255; peBlue := 0; end;
      // 225..256 : begin peRed  := 255;  peGreen:= 255; peBlue := 255; end;
      // end;

      peRed := i;
      peGreen := i;
      peBlue := i;
      peFlags := 0;
      peFlags := 0;
    end;
  Pal^.palNumEntries := 256;
  Pal^.palVersion := $300;
  Palette := CreatePalette(Pal^);
  result := Palette;
  // FreeMem(Pal, SizeOf(TLogPalette) + 256 * SizeOf(TPaletteEntry));
end;

procedure TFormuOSCR.FormCreate(Sender: TObject);
begin

  if InitDll() <> 1 then
    Raise Exception.CreateFmt('Unable init : ''%s''', ['VDSO.dll']);

  SetDevNoticeCallBack(nil, @DevNoticeCallBack, @DevRemoveCallBack);
  SetDataReadyCallBack(nil, @DataReadyCallBack);

end;

procedure TFormuOSCR.btn2Click(Sender: TObject);

var
  stTime: DWORD;
begin
  inherited;
  stTime := timeGetTime;
  GetMem(OSCDoubleBuff, fCaptureLength * 1024 * SizeOf(Double));

  stTime := timeGetTime;
  DataIsReady := False;

  // while not DataIsReady do
  while true do
  begin

    fRealLength := Capture(fCaptureLength, 0);
    fRealLength := fRealLength * 1024;

    while true do
    begin
      Application.ProcessMessages;
      // if timeGetTime > stTime + 5000 then
      // Raise Exception.CreateFmt
      // ('Waiting for data resulted in an error : %d', [5000]);

      if DataIsReady then
      begin
        OnDeviceReadData(OSCDoubleBuff, ReadBytesFromOSC);
        break;
      end;
    end;

    // FreeMem(OSCDoubleBuff);
  end;
  FreeMem(OSCDoubleBuff);

end;

procedure TFormuOSCR.OnDeviceReadData(aData: PDoubleArray; aDataSize: DWORD);
begin
  DataIsReady := False;

  Inc(cnt);
  Label1.CAPTION := Format('%d Read file data len:%d', [cnt, aDataSize]);

  if aDataSize = 0 then
    Exit;

  PaintBox1.Canvas.Brush.Color := clWhite;
  PaintBox1.Canvas.Brush.Style := TBrushStyle.bsSolid;
  PaintBox1.Canvas.FillRect(Rect(Point(0, 0), Point(PaintBox1.Width,
    PaintBox1.Height)));
  PaintBox1.Canvas.Lock;

  var
    f1, f2: Double;

  f1 := -1000000;
  f2 := +10000000;

  var
  j := 0;
  PaintBox1.Canvas.MoveTo(j, 0);
  for var i := 0 to aDataSize - 1 do
  begin

    var
    f := aData[i] * TrackBar1.Position / 10;

    f1 := max(f1, f);
    f2 := min(f2, f);

    if i mod TrackBar2.Position = 0 then
    begin
      if TrackBar2.Position <> 1 then
        PaintBox1.Canvas.MoveTo(j, round(PaintBox1.Height * (0.5 - f1)));
      PaintBox1.Canvas.LineTo(j, round(PaintBox1.Height * (0.5 - f2)));

      f1 := -1000000;
      f2 := +10000000;
      Inc(j);
    end;
    if j > PaintBox1.Width - 20 then
      break;

  end;
  PaintBox1.Canvas.Unlock;

end;

procedure TFormuOSCR.btn4Click(Sender: TObject);
begin
  img1.Picture.Bitmap.Create;
  img1.Picture.Bitmap.Width := img1.Width * 10;
  img1.Picture.Bitmap.Height := img1.Height * 5;
  img1.Picture.Bitmap.PixelFormat := pf8bit;
  img1.Picture.Bitmap.Palette := BW;
  SetLength(FrameDoubleArray, img1.Picture.Bitmap.Height);

    TOSCTV_Create;

  var
    stTime: DWORD;

    stTime := timeGetTime;
    GetMem(OSCDoubleBuff, fCaptureLength * 1024 * SizeOf(Double));

    stTime := timeGetTime;
    DataIsReady := False;




    // while not DataIsReady do
    while true do
    begin

      fRealLength := Capture(fCaptureLength, 0);
      fRealLength := fRealLength * 1024;

      while true do
      begin
        Application.ProcessMessages;
        // if timeGetTime > stTime + 5000 then
        // Raise Exception.CreateFmt
        // ('Waiting for data resulted in an error : %d', [5000]);

        if DataIsReady then
        begin
          OnReadDataTV(OSCDoubleBuff, ReadBytesFromOSC);
          break;
        end;

      end;
   end;
    FreeMem(OSCDoubleBuff);
end;

    procedure TFormuOSCR.tbDeltaChange(Sender: TObject);
    var
      d: Double;
    begin

      d := tbGain.Position;
      ColorVoltageGain := d / 10;
      d := tbDelta.Position;
      ColorVoltageDelta := d / 10;

    end;

    procedure TFormuOSCR.lst1Click(Sender: TObject);
    begin
      SetOscSample(StrToInt(lst1.Items[lst1.ItemIndex]));
    end;

{$IFDEF staticlink1}

initialization

RegisterClass(TFormuOSCR);

{$ENDIF}

end.
